Overview
========
RxGrpc is a new set of gRPC bindings for reactive programming with [RxJava](https://github.com/ReactiveX/RxJava).
RxGprc bindings support unary and streaming operations in both directions. RxGrpc also builds on top of gRPC's
back-pressure support, to deliver end-to-end back-pressure-based flow control in line with RxJava's `Flowable`
back-pressure model.

Usage
=====
To use RxGrpc with the `protobuf-maven-plugin`, add a [custom protoc plugin configuration section](https://www.xolstice.org/protobuf-maven-plugin/examples/protoc-plugin.html).
```xml
<protocPlugins>
    <protocPlugin>
        <id>reactor-grpc</id>
        <groupId>com.salesforce.servicelibs</groupId>
        <artifactId>reactor-grpc</artifactId>
        <version>[VERSION]</version>
        <mainClass>com.salesforce.reactorgrpc.RxGrpcGenerator</mainClass>
    </protocPlugin>
</protocPlugins>
```

After installing the plugin, RxGrpc service stubs will be generated along with your gRPC service stubs.
  
* To implement a service using an RxGrpc service, subclass `Rx[Name]Grpc.[Name]ImplBase` and override the RxJava-based
  methods.
  
  ```
  GreeterGrpc.GreeterImplBase svc = new RxGreeterGrpc.GreeterImplBase() { 
      @Override
      public Single<HelloResponse> sayHello(Single<HelloRequest> rxRequest) {
          return rxRequest.map(protoRequest -> greet("Hello", protoRequest));
      }

      ...

      @Override
      public Flowable<HelloResponse> sayHelloBothStream(Flowable<HelloRequest> rxRequest) {
          return rxRequest
                  .map(HelloRequest::getName)
                  .buffer(2)
                  .map(names -> greet("Hello", String.join(" and ", names)));
      }
  };
  ```
* To call a service using an RxGrpc client, call `Rx[Name]Grpc.newRxStub(Channel channel)`.

  ```
  RxGreeterGrpc.RxGreeterStub stub = RxGreeterGrpc.newRxStub(channel);
  Flowable<HelloRequest> req = Flowable.just(
          HelloRequest.newBuilder().setName("a").build(),
          HelloRequest.newBuilder().setName("b").build(),
          HelloRequest.newBuilder().setName("c").build());
  Flowable<HelloResponse> resp = stub.sayHelloBothStream(req);
  resp.subscribe(...);
  ```
  
Back-pressure
=============
RxGrpc stubs support bi-directional streaming with back-pressure. Under the hood, RxGrpc is built atop the vanilla
gRPC service stubs generated by protoc. As such, they inherit gRPC's HTTP/2-based back-pressure model.

Internally, gRPC and RxGrpc implement a pull-based back-pressure strategy. At the HTTP/2 layer, gRPC maintains a 
buffer of serialized protocol buffer messages. As frames are consumed on the consumer side, the producer is signaled
to transmit more frames. If this producer-side transmit buffer fills, the HTTP/2 layer signals to the gRPC messaging 
layer to stop producing new messages in the stream. RxGrpc handles this signal, applying back-pressure to RxJava
using the `Flowable` api. RxGrpc also implements `Flowable` back-pressure on the consumer side of a stream. As messages
are consumed by the consumer-side `Flowable`, signals are sent down through gRPC and HTTP/2 to request more data.

An example of back-pressure in action can be found in `BackpressureIntegrationTest.java`.

Exception Handling
==============
Exception handling with RxGrpc is a little strange due to the way gRPC deals with errors. Servers that produce an error
by calling `onError(Throwable)` will terminate the call with a `StatusRuntimeException`. The client will have its
`onError(Throwable)` subscription handler called as expected.
 
Exceptions going from client to server are a little less predictable. Depending on the timing, gRPC may cancel
the request before sending any messages due to an exception in the outbound stream.

Modules
=======

RxGrpc is broken down into three sub-modules:

* _rxgrpc_ - a protoc generator for generating gRPC bindings for RxJava.
* _rxgrpc-stub_ - stub classes supporting the generated RxGrpc bindings.
* _rxgrpc-test_ - integration tests for RxGrpc.
